type CustomerData = {
  name?: string | null;
  address?: string | null;
  address_2?: string | null;
  post_code?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  tax_number?: string | null;
  save_customer?: boolean;
};

type BaseDocumentValues = {
  number?: string;
  date?: string;
  customer_id?: string | null;
  customer?: CustomerData | null;

  items?: any[];
  currency_code?: string;
};

/** Map of item index to gross price mode */
type PriceModesMap = Record<number, boolean>;

type PrepareDocumentOptions = {
  /** Original customer data for comparison (to detect modifications) */
  originalCustomer: CustomerData | null;
  /** Whether the customer form was shown to the user */
  wasCustomerFormShown?: boolean;
  /** For invoices/credit notes: whether to mark as paid */
  markAsPaid?: boolean;
  /** For invoices/credit notes: payment type when markAsPaid is true */
  paymentType?: string;
  /** Document type for specific date handling */
  documentType: "invoice" | "estimate" | "credit_note" | "advance_invoice";
  /** Secondary date field value (date_due for invoices, date_valid_till for estimates) */
  secondaryDate?: string;
  /** Map of item index to gross price mode (collected from component state) */
  priceModes?: PriceModesMap;
  /** Whether to save as draft (skips numbering and fiscalization) */
  isDraft?: boolean;
};

/**
 * Prepares document form data for API submission.
 * Handles customer data transformation and payment data for all document types.
 *
 * This is a shared utility for invoices, estimates, and credit notes.
 *
 * @example
 * ```ts
 * // For invoice
 * const payload = prepareDocumentSubmission(values, {
 *   originalCustomer,
 *   wasCustomerFormShown: showCustomerForm,
 *   markAsPaid: values.markAsPaid,
 *   paymentType: values.paymentType,
 *   documentType: "invoice",
 *   secondaryDate: values.date_due,
 * });
 *
 * // For estimate
 * const payload = prepareDocumentSubmission(values, {
 *   originalCustomer,
 *   documentType: "estimate",
 *   secondaryDate: values.date_valid_till,
 * });
 * ```
 */
export function prepareDocumentSubmission<T extends BaseDocumentValues>(
  values: T,
  options: PrepareDocumentOptions,
): any {
  // Document numbers are always auto-generated by the server
  // Remove number from payload (even if form provides a preview value)

  // Handle customer logic
  if (values.customer_id && values.customer) {
    // If customer form was not shown, remove customer data (keep only customer_id)
    if (options.wasCustomerFormShown === false) {
      delete values.customer;
    } else {
      // Existing customer loaded - check if data was actually modified
      const customerChanged =
        options.originalCustomer && JSON.stringify(values.customer) !== JSON.stringify(options.originalCustomer);

      if (!customerChanged) {
        // No changes - send only customer_id
        delete values.customer;
      } else {
        // Changes detected - clean null/empty values and send with save_customer flag
        const cleanedCustomer: any = { save_customer: true };
        for (const [key, value] of Object.entries(values.customer)) {
          if (key !== "save_customer" && value !== "" && value !== null && value !== undefined) {
            cleanedCustomer[key] = value;
          }
        }
        values.customer = cleanedCustomer;
      }
    }
  } else if (values.customer) {
    // New inline customer - clean null/empty values and add save flag
    const cleanedCustomer: any = { save_customer: true };
    let hasAnyValue = false;

    for (const [key, value] of Object.entries(values.customer)) {
      if (key !== "save_customer" && value !== "" && value !== null && value !== undefined) {
        cleanedCustomer[key] = value;
        hasAnyValue = true;
      }
    }

    if (!hasAnyValue) {
      delete values.customer;
    } else {
      values.customer = cleanedCustomer;
    }
  }

  // Clean up customer_id if empty
  if (!values.customer_id) {
    delete values.customer_id;
  }

  // Clean up taxes and handle gross price transformation
  if (values.items) {
    const priceModes = options.priceModes ?? {};
    values.items = values.items.map((item: any, index: number) => {
      const { price, ...rest } = item;

      // Transform price based on price mode (from component state, not form)
      const isGrossPrice = priceModes[index] ?? false;
      const priceFields = isGrossPrice ? { gross_price: price } : { price };

      return {
        ...rest,
        ...priceFields,
        taxes: item.taxes?.map((tax: any) => {
          if (tax.tax_id) {
            // Only send tax_id, API will resolve the rate
            return { tax_id: tax.tax_id };
          }
          return tax;
        }),
      };
    });
  }

  // Build payload with date conversions
  // Destructure to exclude fields we handle explicitly (number is always server-generated)
  const { number: _number, note, payment_terms, ...restValues } = values as any;
  const payload: any = {
    ...restValues,
    ...(note?.trim() && { note: note.trim() }),
    // Advance invoices don't have payment terms - they are documents requesting payment
    ...(options.documentType !== "advance_invoice" && payment_terms?.trim() && { payment_terms: payment_terms.trim() }),
    date: values.date ? new Date(values.date) : undefined,
  };

  // Add secondary date field based on document type
  if ((options.documentType === "invoice" || options.documentType === "advance_invoice") && options.secondaryDate) {
    payload.date_due = new Date(options.secondaryDate);
  } else if (options.documentType === "estimate" && options.secondaryDate) {
    payload.date_valid_till = new Date(options.secondaryDate);
  }
  // Credit notes don't have a secondary date field

  // Handle markAsPaid for invoices and credit notes
  if (options.documentType !== "estimate" && options.markAsPaid) {
    payload.payment = {
      type: options.paymentType || "bank_transfer",
      date: payload.date ?? undefined,
    };
  }

  // Remove UI-only fields from payload
  delete payload.markAsPaid;
  delete payload.paymentType;

  // Add draft flag if requested
  if (options.isDraft) {
    payload.is_draft = true;
  }

  return payload;
}
